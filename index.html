<html>
<head>
<title>CODE</title>
<style>
</style>
<script type="text/javascript">
<!--

var valid_types = ["int", "string", "bool", "function"]; // , "conf", "array"];

var variables = {}; // map from variable name to [type, value]

var builtins = {}; // built-in functions

// get the two parts of a string on each side of some operator
function splitStringAround(str, op) {
	var index = str.indexOf(op);
	if (index == -1) {
		return [str, ""];
	} else {
		return [str.substr(0, index), str.substr(index + op.length)];
	}
}

// builtin: get input from user as a string
function input() {
	return new String(prompt('CODE is requesting input'));
}
builtins["input"] = input;

// builtin: flip a coin
function flipACoin() {
	return new Bool(Math.random() > 0.5 ? "true" : "false");
}
builtins["flip a coin"] = flipACoin;

function equals(a, b) {
	if (a.constructor.name == "Int" && b.constructor.name == "Int") {
		if (a.abs == b.abs && a.negative == b.negative) {
			return new Bool("true");
		}
	}
	else if (a.constructor.name == "String" && b.constructor.name == "String") {
		if (a.value == b.value) {
			return new Bool("true");
		}
	}
	else if (a.constructor.name == "Bool" && b.constructor.name == "Bool") {
		if (a.value == b.value) {
			return new Bool("true");
		}
	}
	return new Bool("false");
}

function plus(a, b) {
	if (a.constructor.name == "Int" && b.constructor.name == "Int") {
		if (a.negative == b.negative) {
			return new Int("", a.negative, a.abs + b.abs);
		} else {
			var negative = (a.negative && a.abs >= b.abs) || (!a.negative && a.abs < b.abs);
			var abs = a.abs - b.abs;
			if (abs < 0) abs = -abs;
			return new Int("", negative, abs);
		}
	}
	else if (a.constructor.name == "String" || b.constructor.name == "String") {
		return a.toString() + b.toString();
	}
	return new Int("-1");
}

function minus(a, b) {
	if (a.constructor.name == "Int" && b.constructor.name == "Int") {
		var negb = new Int("", !b.negative, b.abs);
		return plus(a, negb);
	}
	return new Int("-1");
	
	// string minus string: remove first instance of 2nd string from 1st string
}

function lt(a, b) {
	if (a.constructor.name == "Int" && b.constructor.name == "Int") {
		if (a.negative && b.negative && a.abs > b.abs) {
			return new Bool("true");
		} else if (!a.negative && !b.negative && a.abs < b.abs) {
			return new Bool("true");
		} else if (a.negative && !b.negative) {
			return new Bool("true");
		}
	}
	else if (a.constructor.name == "String" && b.constructor.name == "String") {
		if (a.value < b.value) {
			return new Bool("true");
		}
	}
	else if (a.constructor.name == "Bool" && b.constructor.name == "Bool") {
		if (a.value == "false" && b.value == "true") {
			return new Bool("true");
		}
	}
	return new Bool("false");
}

function gt(a, b) {
	return lt(b, a);
}

// string times int: repeat string int times, if positive. if negative, reverse it

// stores an int (which can be as big as, but not including, Number.MAX_SAFE_INTEGER)
// negative 0 is allowed
class Int {
	max = Number.MAX_SAFE_INTEGER;
	constructor(str, negative=undefined, abs=undefined) {
		if (typeof str == "object") {
			if (str.constructor.name == "Bool" || str.constructor.name == "String") {
				str = str.value;
			} else if (str.constructor.name == "Int") {
				negative = str.negative;
				abs = str.abs;
			}
		}
		if (negative !== undefined && abs !== undefined) {
			this.negative = negative;
			this.abs = abs;
			return;
		}
		this.negative = false;
		if (str.startsWith("-")) {
			this.negative = true;
			str = str.substr(1);
		}
		this.abs = parseInt(str); // should be positive
		// on error, make it negative one in the hope somebody will do error checking
		if (this.abs > this.max || isNaN(this.abs)) {
			this.abs = -1;
		}
	}
	
	toString() {
		var sign = "";
		if (this.negative) sign = "-";
		if (Object.is(this.abs, -0)) {
			// javascript treats -0 the same as 0 for some reason
			return sign + "-0";
		} else {
			return sign + this.abs;
		}
	}
	
	parenOperator() {
		return new Int("", !this.negative, this.abs);
	}
}

// your boring old string class
class String {
	constructor(str) {
		if (typeof str == "object") {
			this.value = str.toString();
		} else {
			this.value = str;
		}
	}
	
	toString() {
		return this.value;
	}
	
	parenOperator() {
		return eval(this.value);
	}
}

// stores a boolean, which can be true, false, or neither
class Bool {
	constructor(str) {
		if (typeof str == "object") {
			if (str.constructor.name == "Bool" || str.constructor.name == "String") {
				str = str.value;
			} else if (str.constructor.name == "Int") {
				this.value = !str.negative;
				return;
			}
		}
		if (str.toLowerCase().startsWith("t")) {
			this.value = "true";
		} else if (str.toLowerCase().startsWith("f")) {
			this.value = "false";
		} else {
			this.value = "neither";
		}
	}
	
	toString() {
		return this.value;
	}
	
	parenOperator() {
		if (this.value == "true") {
			return new Bool("false");
		} else if (this.value == "false") {
			return new Bool("true");
		} else {
			return new Bool("neither");
		}
	}
}

class Function {
	constructor() {
		this.code = [];
	}
	
	add(str) {
		this.code.push(str);
	}
	
	toString() {
		return this.code.join("\n");
	}
	
	parenOperator() {
		if (this.value == "true") {
			return new Bool("false");
		} else if (this.value == "false") {
			return new Bool("true");
		} else {
			return new Bool("neither");
		}
	}
	
	eval() {
		var last_line_value = new Int("-1");
		var indents = 0;
		var next_indents = count_indents(this.code[0]);
		for (var i=0; i<this.code.length; i++) {
			// move indents and next_indents forward
			indents = next_indents;
			if (i >= this.code.length - 1) {
				next_indents = -1;
			} else {
				next_indents = count_indents(this.code[i+1]);
			}
			
			if (next_indents > indents) {
				// this is an if statement. evaluate it and convert to boolean. if it's true, continue forwards; otherwise, skip until we find another line with at most this many indents.
				last_line_value = eval(this.code[i].substr(indents), false);
				console.log(this.code[i].substr(indents) + " => " + last_line_value);
				var bool_value = new Bool(last_line_value);
				if (bool_value.value != "true") {
					var next_i = i + 1;
					while (next_i < this.code.length && count_indents(this.code[next_i]) > indents) {
						next_i++;
					}
					i = next_i - 1;
					if (next_i < this.code.length) {
						next_indents = count_indents(this.code[next_i]);
					} else {
						next_indents = -1;
					}
					continue;
				}
				
			} else {
				// evaluate it and continue forward
				last_line_value = eval(this.code[i].substr(indents));
				console.log(this.code[i].substr(indents) + " => " + last_line_value);
			}
		}
		return last_line_value;
	}
	
	toString() {
		return this.value;
	}
	
	parenOperator() {
		return this; // can we do anything fun with this? actually it may not be possible to ever do any operator on a raw function anyway, since it'll always get evaluated
	}
}

function eval(line, canBeEqualsStatement = true) {
	var evaluated = false; // evaluate each line only once
	
	// https://www.adl.org/resources/hate-symbol/echo
	// todo add more hate symbols
	if (/\(\(\(.*\)\)\)/.test(line)) {
		console.log("No hate symbols please");
		evaluated = true;
		return new Int(-1);
	}	
		
	// print something
	if (line.startsWith("print ")) {
		window.print();
		var printed_expr = parseExpression(line.substr(6));
		document.getElementById('out').innerHTML += printed_expr.toString() + "<br>";
		evaluated = true;
		return printed_expr;
	}
	if (line.startsWith("print(") && line.endsWith(")")) {
		var printed_expr = parseExpression(line.substr(6, line.length - 7));
		console.log(line.substr(6, line.length - 7));
		document.getElementById('out').innerHTML += printed_expr.toString() + "<br>";
		evaluated = true;
		return printed_expr;
	}
	
	// the equals operator
	if (!evaluated && canBeEqualsStatement && line.indexOf(" = ") > -1) {
		var [lhs, rhs] = splitStringAround(line, " = ");
		if (valid_types.includes(rhs)) {
			variables[lhs] = [rhs, new String("nothing")];
			evaluated = true;
			return new String(rhs);
		} else if (lhs in variables && valid_types.includes(variables[lhs][0])) {
			// set the variable to rhs
			if (variables[lhs][0] == "int") {
				var parsedRhs = parseExpression(rhs)
				variables[lhs][1] = new Int(parsedRhs);
			} else if (variables[lhs][0] == "string") {
				var parsedRhs = parseExpression(rhs)
				variables[lhs][1] = new String(parsedRhs);
			} else if (variables[lhs][0] == "bool") {
				var parsedRhs = parseExpression(rhs)
				variables[lhs][1] = new Bool(parsedRhs);
			} else if (variables[lhs][0] == "function") {
				// don't parse, just set the string
				if (variables[lhs][1] === undefined || variables[lhs][1].constructor.name != "Function") {
					variables[lhs][1] = new Function(rhs);
				}
				console.log(rhs);
				console.log(variables[lhs][1]);
				variables[lhs][1].add(rhs);
			}
			evaluated = true;
			return variables[lhs][1];
		}
	}
	
	// just parse it, it might do something
	if (!evaluated) {
		return parseExpression(line);
	}
	
	// todo: handle if statements by checking if this line should be parsed or not
}

// parse an expression and return its value
// the result should be one of our objects
function parseExpression(str) {
	console.log(str);
	if (str.startsWith("(") && str.endsWith(")")) {
		var inner = str.substring(1, str.length - 1)
		return parseExpression(inner).parenOperator();
	} else if (str.startsWith('"') && str.endsWith('"')) {
		var inner = str.substring(1, str.length - 1)
		return new String(inner);
	} else if (str.indexOf(" = ") > -1) {
		var [lhs, rhs] = splitStringAround(str, " = ");
		return equals(parseExpression(lhs), parseExpression(rhs));
	} else if (str.indexOf(" + ") > -1) {
		var [lhs, rhs] = splitStringAround(str, " + ");
		return plus(parseExpression(lhs), parseExpression(rhs));
	} else if (str.indexOf(" - ") > -1) {
		var [lhs, rhs] = splitStringAround(str, " - ");
		return minus(parseExpression(lhs), parseExpression(rhs));
	} else if (str.indexOf(" < ") > -1) {
		var [lhs, rhs] = splitStringAround(str, " < ");
		return lt(parseExpression(lhs), parseExpression(rhs));
	} else if (str.indexOf(" > ") > -1) {
		var [lhs, rhs] = splitStringAround(str, " > ");
		return gt(parseExpression(lhs), parseExpression(rhs));
	}
	// todo: times, divided by, ÷, ÷÷, and, or

	// try evaluating the string as a variable/function/builtin
	if (str in builtins) {
		return builtins[str]();
	}
	if (str in variables) {
		var result = variables[str][1];
		if (result.constructor.name == "Function") {
			return result.eval();
		} else {
			return result;
		}
	}
	// try parsing
	if (str.toLowerCase() == "true" || str.toLowerCase() == "false") {
		return new Bool(str);
	}
	if (/^\-*\d+$/.test(str)) {
		return new Int(str);
	}
	return new String(str);
}

function count_indents(line) {
	var indents = 0;
	for (var i=0; i<line.length; i++) {
		if (line[i] == " ") {
			indents++;
		} else {
			break;
		}
	}
	return indents;
}

function run() {
	var code = document.getElementById('in').value.split("\n");
	document.getElementById('out').innerHTML = "";
	
	var indents = 0;
	var next_indents = count_indents(code[0]);
	for (var i=0; i<code.length; i++) {
		// move indents and next_indents forward
		indents = next_indents;
		if (i >= code.length - 1) {
			next_indents = -1;
		} else {
			next_indents = count_indents(code[i+1]);
		}
		
		if (next_indents > indents) {
			// this is an if statement. evaluate it and convert to boolean. if it's true, continue forwards; otherwise, skip until we find another line with at most this many indents.
			var value = new Bool(eval(code[i].substr(indents), false));
			if (value.value != "true") {
				var next_i = i + 1;
				while (next_i < code.length && count_indents(code[next_i]) > indents) {
					next_i++;
				}
				i = next_i - 1;
				next_indents = count_indents(code[next_i])
				continue;
			}
			
		} else {
			// evaluate it and continue forward
			eval(code[i].substr(indents));
		}
	}
}
// -->
</script>
</head>
<body>
<textarea id="in" cols=100 rows=20>Code goes here!</textarea><br>
<input type="submit" onclick="run()" /><br><br>
<div id="out">
</body>
</html>